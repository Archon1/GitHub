{"name":"Github","tagline":"https://github.com/Archon1/Java-JavaScript-JQuery-Cheat-Sheet-Notes.git","body":"JAVA Basics\r\n\r\nVariables.\r\nJAVA PRIMITIVES:\r\n----------------\r\nvariables and function return-types can be any Java Primitive type\r\n- int\t\t32 bits\t\tsigned integers -2,147,483,648 to +2,147,438,647 (-2^31 to +2^31 - 1)\r\n- long\t\t64 bits\t\tsigned integers -2^63 to +2^63 - 1\r\n- char\t\t16 bits\t\tunicode char set\r\n- short\t\t16 bits\t\tsigned integers -32,768 to +31767 (-2^15 to +2^15 - 1)\r\n- byte\t\t 8 bits \tsigned integers -128 to +127      (-2^7  to  +2^7 - 1)\r\n- float\t\t32 bytes\tsigned floating point numbers\r\n- double\t64 bits\t\tsigned floating point numbers\r\n- boolean\ttrue or false values\r\n- void (used in methods to indicate no return-type)\r\n\r\nother non-primitve JAVA data types:\r\n- array\r\n- Class (object)\r\n- Point (pointers)\r\n\r\nto declare a constant:\r\nfinal string  RED_LIGHT      = 'stop';\r\nfinal int     INCH_FOOT      = 12;\r\nfinal float   TEMP_C_TO_F    = 1.8;\r\nfinal Boolean RETURN_SUCCESS = true;\r\n\r\nLiterals:\r\n#### Numeric Literals ####\r\nTo make a numeric value a numeric-literal;\r\nlong pennyTotal = 0;          // (example) declare a variable type=long\r\npennytotal = pennyTotal + 4L; // (example) 4 is a Literal of type=long\r\n\r\nBinary Values (Base 2): \r\n   0b111     = 111[base-2]     =  7[base-10]\r\n   0b1010101 = 1010101[base-2] = 85[base-10]\r\nOctal Values (Base 8)\r\n   0o10      = 10[base-8]      =  8[base-10]\r\n   0o125     = 125[base-8]     = 85[base-10]\r\nHexadecimal Values (Base 16)\r\n   0x1F      = 1F[base-16]     = 31[base-10]\r\n   0xA8      = A8[base-16]     = 168[base-10]\r\n\r\n#### Character Literals ####\r\nCharacter escape-codes are one set of examples. All Escape-code are preceded by '\\' (backslash);\r\n\\n\tNew Line  char(13)+char(10)\r\n\\t\tTab       char(9)\r\n\\b\tBackspace\r\n\\r\tReturn    char(13)\r\n\\f\tFormfeed\r\n\\\\\tBackslash\r\n\\'\tSingle Quote-mark char(39)\r\n\\\"\tDouble Quote-mark char(34)\r\n\\d\toctal (must be an underlined 'd')\r\n\\xd\thexadecimal (must be an underlined 'd')       also: \\x21 = 21[base-16] = 33[base-10]\r\n\\ud\tUnicode character (must be an underlined 'd') also: \\u2122 = 2122[unicode] = TM (trademark symbol)\r\n\r\nfor  number-strings;\r\nint 1_234_567 = 1,234,577 = 1234567 (numeric)\r\n\r\nExponents (Doubles, Floats):\r\n  double var1 = 12e22;\t\t// 12 * 10^22\r\n  double var2 = 11.9e22;\t// 11.9 * 10^22\r\n  double var3 = 12e-45;\t\t// 12 * 10^-45 (12 / 10^45)\r\n\r\n\r\nValues must be assigned to local variables before tehy're used, or a java class|program won't compile successfully.\r\nvariable\t'default\r\ntype\t\t value'\r\n--------\t---------\r\nnumeric\t\t0\r\ncharacter\t'\\0'\r\nstrings\t\t''\r\nBoolean\t\tfalse\r\nObjects\t\tnull\r\nVariable name convention: first letter is lowercase\r\nConstant name convention: All letters are uppercase\r\nJava names, classes, variables, etc. are case-sensitive.\r\n\r\nJAVA Operators\r\n==============\r\nJAVA Operator precedence:\r\n--------------------------\r\n(BASIC)\r\n++ --\t Increment, Decrement \r\n+ - * /\t Arithmetic (add, subtract, multiply, divide)\r\n== != > <\r\n<= >= <> Comparison (equal, not-equal, less-then, greater-than, etc.)\r\n&  |  ^\t Logical Bitwise (and, or, xor)\r\n&& ||    Logical AND, OR\r\n=\t Assignment expressions\r\n\r\n(FULL JAVA operator Precedence listing)\r\n---------------------------------------\r\n.  []  ()\t\tAccessMethod(dot-operator), Array-Brackets, Parentheses\r\n++  --  !  ~ instanceof\t[not] instanceof returns TRUE or FALSE (object [not] ~instanceof(ClassName))\r\n\t\t\tincrement, decrement\r\nnew (type)expression\tnew instance creation, Parentheses used to Cast values to another type\r\n*  /  %\t\t\tMultiplication, Division, Modulus (remainder)\r\n+  -\t\t\tAddition, Subtraction\r\n<<  >>  >>>\t\tBitwise left or right shift\r\n<>  >=  <=\t\tRelational comparison tests\r\n==  !=\t\t\tEquality comparison tests\r\n&\t\t\tAND/bitwise\r\n^\t\t\tXOR/bitwase\r\n|\t\t\tOR/bitwise\r\n&&\t\t\tAND/logical\r\n||\t\t\tOR/Logical\r\n? :\t\t\tTernary Operator. return = (BooleanExpression ? TrueResp : FalseResp);\r\n%=  +=  .=  -=  /=  ^=\t(shorthand) Assignment Operators )(also plain old = assignemnts)\r\n&= !=  <<=  >>=  >>>=\t(other)  Assignment Operators\r\n\r\nBitwise operator meanings:\r\n>>\tShift right with sign extension\r\n<<\tShift left with zero fill\r\n>>>\tShift right with zero fill\r\n\r\n16 >> 2 yields 4\r\n16      = 0001 0000\r\nshift 2 = 0000 0100, which = 4\r\n\r\n128 >> 2 yields 224\r\n128     = 1000 0000\r\nshift 2 = 1110 0000, which  = 224\r\n>> fills the leftmost bit with its previous value\r\n\r\n128 >>>  2 yields 32\r\n128     = 1000 0000\r\nshift 2 = 0010 0000, which = 32 \r\n>>> fills the leftmost bit with 0\r\n\r\nx = x << 2 is equivalent to x <<= 2\r\n\r\n-------------------------------------------------------\r\nString 'math':\r\n--------------\r\nSystem.out.println(\"Four Score and \" + 7 + \"years ago\"); // OK because println() is overloaded for multiple data types\r\n\r\npublic void sysPrintLn( String[] args ) {\r\n\tint prtArgs = args.length - 1;\r\n\tfor (int i=0; i<args.length; i++) {\r\n\t\tSystem.out.print(args[i]);\r\n\t\tif (i < prtArgs) {System.out.print(' ');}\r\n\t\telse {System.Out.print('\\n');}\r\n\t}\r\n}\r\n\r\nfloat investment = 14000.00;\r\ninvestment *= 1.4;   // increase by 40% year 1\r\ninvestment -= 1500;  // lost $1500      year 2\r\ninvestment *= 1.12;  // increase by 12% year 3\r\nOR\r\ninvestment = (((investment * 1.4) - 1500) * 1.2); // each year's activity in a new set of paretheses\r\n\r\npublic void divide_remain( int main, int divisor) {\r\n\tint quotient  = main / divisor;\r\n\tint remainder = main % divisor;\r\n\tSystem.out.println(main+'/'+divisor+' = '+quotient + '\\tremainder = '+remainder);\r\n}\r\n\r\nclass Customer {\r\n\tclass Order {\r\n\t\tprivate String orderID = '';\r\n\t\tprivate int orderStatus = 0; // 0=no status, 10=pending, 20=paid, 30=shipped, 40=canceled , other values...\r\n\t\tprivate Boolean fileComplaint = false;\r\n\r\n\t\t// class code here\r\n\r\n\r\n\t\tpublic Order cancelOrder(object Order) {\r\n\t\t\t// this method returns an Order object\r\n\t\t\tif (this.orderID = Order.orderNum) {\r\n\t\t\t\tthis.Order.orderStatus = 40;\r\n\t\t\t}\r\n\t\t\treturn this.Order;\r\n\t\t}\r\n\t\tpublic Boolean changeComplaintStatus() {\r\n\t\t\tthis.fileComplaint = !this.fileComplaint;\r\n\t\t}\r\n\t\tpublic void fileComplaint(object Order) {\r\n\t\t\tif (this.fileComplaint == true) {\r\n\t\t\t// code\r\n\t\t\t}\r\n\t\t}\r\n\t} \t// end class Order\r\n}\t\t// end class Customer\r\n\r\nFormatting Strings:\r\n-------------------\r\nint accountBalance = 5001;                             // input an int value\r\nSystem.out.format(\"Balance: $%,%dn\", accountBalance);  // produces '%5,001'\r\ndouble pi = Math.PI;                                   // store Math.PI to variable because Math.PI is static, final\r\nSystem.out.format(\"pi = %.11f%n\",pi);                  // produces '3.14159265359'\r\nfloat gradePtAvg = 3.25F;\t\t// Numeric Literal (F = Floating Point nuber, or float)\r\nSystem.out.println(\"My GPA is \" + gpa);\r\n\r\n\r\nCASTING:\r\n----------------------------\r\nClass Employee {\r\n\t// Base class\r\n\t// code for this class\r\n}\r\nclass VicePresident extends Employee {\r\n\t// inherits from Employee{}\r\n\t// code for this class\r\n}\r\nEmployee      emp  = new Employee();      // emp  is a member of the Employee      class\r\nVicePresident veep = new VicePresident(); // veep is a member of the VicePresident class\r\n// because all VicePresidents are Employees\r\nemp  = veep;               // no type-casting needed for Upward use ('upcasting')\r\n// But because only some Employees are VicePresidents\r\nveep = (VicePresident)emp; // Explicit type-casting needed for this ('downcasting')\r\n\r\n\r\nINSTANCES Value and Equality\r\n-----------------------\r\npublic static void main(String[] args) {\r\n\tString str1, str2;\r\n\tstr1 = \"We the People\";\r\n\t\r\n\tstr2 = str1;\t\t // assignment: str1 and str2 refer to the same object instance\r\n\tSystem.out.println(\"Same Object? \"+(str1 == str2));\t// prints 'true'\r\n\tSystem.out.println(\"Same value?  \"+str1.equals(str2));\t// prints 'true'\r\n\t\r\n\tstr2 = new String(str1); // assignment: create a new String object, set value = str1\r\n\tSystem.out.println(\"Same Object? \"+(str1 == str2));\t// prints 'false'\r\n\tSystem.out.println(\"Same value?  \"+str1.equals(str2));\t// prints 'true'\r\n}\r\n\r\nARRAYS in JAVA:\r\n===============\r\nString players = new String[11]; // create an array with 11 strings, name = 'players'\r\n\r\n\r\n/////////////////////////////////////////////////////////////////\r\n// Object Oriented Programming (simple example):\r\n// This application will display a 'Hello World!' message on a\r\n// user's console by creating n instance of the Greeter class,\r\n// and then calling the Greeter Object's sayHello() method.\r\n////////////////////////////////////////////////////////////////\r\npublic class HelloApp\r\n{\r\n   \r\n   public static void main(String[] args)\r\n   {\r\n       private boolean passArgs;\r\n       private String  argPassList = '';\r\n       \r\n       if (args.length < 1) \r\n       {   // just put the 'Hello World!' message out to the Console\r\n           passArgs = false;\r\n           ConsoleGreeter myGreeterObject = new ConsoleGreeter();\r\n       }\r\n       else if (args.length == 1) \r\n       {\r\n           if (args[0].equalsIgnoreCase(\"response-window\") \r\n           {   // just put the 'Hello World!' message out to a RepsonseWindow\r\n               passArgs    = false;\r\n               RespWinGreeter myGreeterObject = new RespWinGreeter();\r\n           }\r\n           else\r\n           {\r\n               passArgs    = true;\r\n               argPassList = args[0];\r\n               ConsoleGreeter myGreeterObject = new ConsoleGreeter();\r\n           }\r\n       }\r\n       else // if (args.length >= 1)\r\n       {\r\n           passArgs = true;\r\n           \r\n           int start;\r\n           start = (args[0].equalsIgnoreCase(\"response-window\")) ? 1 : 0 ;\r\n           \r\n           argPassList = assemblePhrase(args, start)\r\n           argPassList = argPassList.trim();\r\n           \r\n           if (start == 1) \r\n           {   // args[0] = 'response-window'\r\n               RespWinGreeter myGreeterObject = new RespWinGreeter();\r\n           }\r\n           else \r\n           {\r\n               ConsoleGreeter myGreeterObject = new ConsoleGreeter();\r\n           }   // ... if (start == 1)\r\n       }       // ... if (args.length < 1)\r\n       \r\n       if (passArgs == true) \r\n       {\r\n               myGreeterObject.sayHello(argPassList);\r\n       }\r\n       else // passArgs = false\r\n       {\r\n               myGreeterObject.sayHello();\r\n       }      // ... if (passArgs == true) \r\n   }          // end main()\r\n   \r\n   public string assemblePhrase(String strArray, int startArg)\r\n   {\r\n       String returnStr = '';\r\n       for (int i = startArg; i < strArray.length; i++)\r\n       {\r\n           returnStr = returnStr + ' ' + strArray[i];\r\n       }\r\n       return returnStr;\r\n   }\r\n\r\n// end of class HelloApp\r\n}\r\n\r\npublic class ConsoleGreeter\r\n{\r\n   public void sayHello()\r\n   {\r\n       System.out.println(\"Hello World!\");\r\n   }\r\n   public void sayHello(String[] toWhom)\r\n   {\r\n       String toYou = HelloApp.assemblePhrase(toWhom,0);\r\n       System.out.println(\"Hello\" + toYou + \"!\");\r\n   }\r\n// end of class ConsoleGreeter\r\n}\r\n\r\npublic class RespWinGreeter\r\n{\r\n   public void sayHello()\r\n   {\r\n       JOptionPane.showMessageDialog(null, \"Hello World!\", JOptionPane.INFORMATION_MESAGE);\r\n   }\r\n   public void sayHello(String[] toWhom)\r\n   {\r\n       String toYou = HelloApp.assemblePhrase(toWhom,0);\r\n       JOptionPane.showMessageDialog(null, \"Hello\" + toYou + \"!\", JOptionPane.INFORMATION_MESAGE);\r\n   }\r\n// end of class RespWinGreeter\r\n}\r\n\r\nJAVA INNER CLASS\r\nInner Classes (example):\r\n-------------------------\r\nClass OuterClassName\r\n{\r\n    public static void main(string[] args)\r\n    {\r\n       // main() method code \r\n    }\r\n    \r\n    private class InnerClassName\r\n    {\r\n       // code defining the body of the inner class\r\n       // inner classes can have private, public, or protected visibility\r\n       // inner classes carry a reference to the outerClass\r\n       // inner-classes have access to all fields, methods, and instance-variables of their outer-class\r\n       // because of the outer-class reference, you can create or refer to inner-classes from outer-class static methods -- e.g. main() -- \r\n       // BUT you can create a static inner-class\r\n    }\r\n}\r\n\r\nANONYMOUS CLASS\r\nAnonymous Classes (example):\r\n------------------------------\r\npublic class AnonymousClassBall\r\n{\r\n   public static void main(string[] args) \r\n   {\r\n       Ball b = new Ball()\r\n       {\r\n           public void hitBall()\r\n           {\r\n               System.out.println(\"You hit the Ball!\");\r\n           }\r\n       }; // note - this ends the new Ball() statement\r\n       b.hitBall();\r\n   }\r\n   \r\n   interface Ball // interface for AnonymousClassBall\r\n   {\r\n       void hitBall();\r\n   }\r\n}\r\n\r\nTo delcare and instantiate the AnonymousClassBall class;\r\nnew AnonymousClassball() { class-body } // call the Anonymous class directly\r\nOR\r\nnew Ball() { class-body } // call the interface that implements the Anynymous class\r\n\r\n\r\nLambda Expressions:\r\n---------------------\r\nA lambda expression allows creation of an anonymous class instance that implements a functional interface.\r\nThe hitBall() method, in the AnonymousClassBall{} class, meets that definition.\r\nA functional interface must contain one abstract method, and may contain other concrete methods.\r\n\r\nLambda functions are a quick way to create anonymous classes that implement functional interfaces. Instead of defining a formal method declaration which includes a return-type, method-name, parameter-types, and method-body-code, you just define teh parameter types and method-body-commands. The Java compiler infers the rest, based on the context of the Lambda expression.\r\nExample:\r\n() -> { System.out.println(\"You hit the ball!\");} // this Lambda-Expression implements the interface whose abstract method takes no parameters.\r\n\"->\" = 'Arrow Operator'\r\n\r\nFor the anonymous class above, the coding would look like  this:\r\n\r\npublic class LambdaBall\r\n{\r\n   public static void main(string[] args) \r\n   {\r\n       Ball b = () -> {System.out.println(\"You hit the Ball!\");}; // notice 2 semicolons: 1=end of embedded lambda-command,2=end of main() command\r\n       b.hitBall();\r\n   }\r\n   \r\n   interface Ball // interface for LambdaBall\r\n   {\r\n       void hitBall();\r\n   }\r\n}\r\n\r\n\r\nSTATIC FIELDS & METHODS:\r\n------------------------\r\nStatic fields and methods are asociated with an entire Class, not a specific Object which is an instance of the Class. \r\nIt's not necessary to crate an 'instance of the class' (object) in order to access a Static Variable or Static Method.\r\n\r\nUses/reasons for Static fields and methods:\r\n1. To provide constants or other values that aren't tied to a spacific class instance (example: a tax rate applicable to all taxable items)\r\n2. To keep a count of how many instances of a class have been created or are active\r\n3. To maintain a reference value (e.g. invoice numbers, or serial numbers which are incremented or generated according a set of rules).\r\n4. To provide alternative ways to crete class instances. Example: Java NumberFormat class has getCurrencyInstance() and getNumberInstance that return Object instances to format numeric values in specific ways.\r\n   Note: the NumberFormat example also describes a 'Singleton Class' and Singleton Pattern.\r\n5. To provide a set of utility functions to a Class that aren't associated with a specific object. Examples include many types of data validation.\r\n\r\nStatic variables or fields can be declared  private outside of any class methods. BUT...\r\n... Because static variables and methods are available to an entire class (all instances or objects of the Class Type), static variables can't be declared in private methods.\r\n\r\nSINGLETON PATTERN\r\n-----------------\r\nA singleton is a class where only ONE instance is created.  \r\nCreating a private constructor will prevent the class from being instantiated externally.\r\nCreating a public method that controls instantiation allows one and only one instance of the class to be created.\r\n\r\npublic class SingletonClass \r\n{\r\n   private static SingletonClass instance;   // delcare a Field for an instance reference\r\n   // this variable maintains a reference to an object (instance of the Class)\r\n\r\n   private SingletonClass() {}               // default constructor for instance reference\r\n   // declaring this private will pevent the constructor from being used or called from\r\n   // outside the Class, and thus prevent new instances from being instantiated if one already exists\r\n   \r\n   public static SingletonClass getInstance()\r\n   {                                         // static function -- same method used by all class instances\r\n       if (instance == null) {               // if there is no instance\r\n            instance = new SingletonClass(); // then create one [set the private static Field, above]\r\n       }\r\n       return instance;                      // return a reference to the instance\r\n   }\r\n}\r\n\r\n//////////////////////////////////////////\r\n// commands to run the Singleton Class: //\r\n//////////////////////////////////////////\r\nSingletonClass obj1 = SingletonClass.getInstance();\r\nSingletonClass obj2 = SingletonClass.getInstance();\r\nif (obj1 == obj2) {\r\n    System.out.println(\"The objects are the same.\");\r\n}\r\nelse {\r\n    System.out.println(\"The objects are not the same.\");\r\n}\r\n\r\nActual code snippet from the Java Math Class:\r\n=============================================\r\npublic final class Math {\r\n   \r\n   /** \r\n    * Don't allow anyone to instantiate this class\r\n    */\r\n   private Math() {}\r\n   ...\r\n   ... much more code\r\n   ...\r\n}\r\n\r\nEMBEDDED JAVA:\r\nhttp://www.onjava.com/pub/st/54\r\n\r\nTutorial:\r\nhttp://www.oracle.com/technetwork/java/index.html\r\nhttp://www.onjava.com/pub/a/onjava/synd/2001/08/15/embedded.html\r\nSECURITY:\r\nhttp://www.pcworld.com/article/2030778/researchers-javas-security-problems-unlikely-to-be-resolved-soon.html\r\n\r\nJVM\r\n====\r\nJVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.  \r\nJVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent. \r\nThe JVM performs following main tasks: •Loads code\r\n•Verifies code\r\n•Executes code\r\n•Provides runtime environment\r\n \r\nJRE\r\n====\r\nJRE is an acronym for Java Runtime Environment.It is used to provide runtime environment.It is the implementation of JVM.It physically exists.It contains set of libraries + other files that JVM uses at runtime.  \r\nImplementation of JVMs are also actively released by other companies besides Sun Micro Systems.  \r\n\r\nJDK\r\n====\r\nJDK is an acronym for Java Development Kit.It physically exists.It contains JRE + development tools.  \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}