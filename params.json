{"name":"Github","tagline":"https://github.com/Archon1/Java-JavaScript-JQuery-Cheat-Sheet-Notes.git","body":"JAVA Basics\r\n\r\nVariables.\r\nJAVA PRIMITIVES:\r\n----------------\r\nvariables and function return-types can be any Java Primitive type\r\n- int\t\t32 bits\t\tsigned integers -2,147,483,648 to +2,147,438,647 (-2^31 to +2^31 - 1)\r\n- long\t\t64 bits\t\tsigned integers -2^63 to +2^63 - 1\r\n- char\t\t16 bits\t\tunicode char set\r\n- short\t\t16 bits\t\tsigned integers -32,768 to +31767 (-2^15 to +2^15 - 1)\r\n- byte\t\t 8 bits \tsigned integers -128 to +127      (-2^7  to  +2^7 - 1)\r\n- float\t\t32 bytes\tsigned floating point numbers\r\n- double\t64 bits\t\tsigned floating point numbers\r\n- boolean\ttrue or false values\r\n- void (used in methods to indicate no return-type)\r\n\r\nother non-primitve JAVA data types:\r\n- array\r\n- Class (object)\r\n- Point (pointers)\r\n\r\nto declare a constant:\r\nfinal string  RED_LIGHT      = 'stop';\r\nfinal int     INCH_FOOT      = 12;\r\nfinal float   TEMP_C_TO_F    = 1.8;\r\nfinal Boolean RETURN_SUCCESS = true;\r\n\r\nLiterals:\r\n#### Numeric Literals ####\r\nTo make a numeric value a numeric-literal;\r\nlong pennyTotal = 0;          // (example) declare a variable type=long\r\npennytotal = pennyTotal + 4L; // (example) 4 is a Literal of type=long\r\n\r\nBinary Values (Base 2): \r\n   0b111     = 111[base-2]     =  7[base-10]\r\n   0b1010101 = 1010101[base-2] = 85[base-10]\r\nOctal Values (Base 8)\r\n   0o10      = 10[base-8]      =  8[base-10]\r\n   0o125     = 125[base-8]     = 85[base-10]\r\nHexadecimal Values (Base 16)\r\n   0x1F      = 1F[base-16]     = 31[base-10]\r\n   0xA8      = A8[base-16]     = 168[base-10]\r\n\r\n#### Character Literals ####\r\nCharacter escape-codes are one set of examples. All Escape-code are preceded by '\\' (backslash);\r\n\\n\tNew Line  char(13)+char(10)\r\n\\t\tTab       char(9)\r\n\\b\tBackspace\r\n\\r\tReturn    char(13)\r\n\\f\tFormfeed\r\n\\\\\tBackslash\r\n\\'\tSingle Quote-mark char(39)\r\n\\\"\tDouble Quote-mark char(34)\r\n\\d\toctal (must be an underlined 'd')\r\n\\xd\thexadecimal (must be an underlined 'd')       also: \\x21 = 21[base-16] = 33[base-10]\r\n\\ud\tUnicode character (must be an underlined 'd') also: \\u2122 = 2122[unicode] = TM (trademark symbol)\r\n\r\nfor  number-strings;\r\nint 1_234_567 = 1,234,577 = 1234567 (numeric)\r\n\r\nExponents (Doubles, Floats):\r\n  double var1 = 12e22;\t\t// 12 * 10^22\r\n  double var2 = 11.9e22;\t// 11.9 * 10^22\r\n  double var3 = 12e-45;\t\t// 12 * 10^-45 (12 / 10^45)\r\n\r\n\r\nValues must be assigned to local variables before tehy're used, or a java class|program won't compile successfully.\r\nvariable\t'default\r\ntype\t\t value'\r\n--------\t---------\r\nnumeric\t\t0\r\ncharacter\t'\\0'\r\nstrings\t\t''\r\nBoolean\t\tfalse\r\nObjects\t\tnull\r\nVariable name convention: first letter is lowercase\r\nConstant name convention: All letters are uppercase\r\nJava names, classes, variables, etc. are case-sensitive.\r\n\r\nJAVA Operators\r\n==============\r\nJAVA Operator precedence:\r\n--------------------------\r\n(BASIC)\r\n++ --\t Increment, Decrement \r\n+ - * /\t Arithmetic (add, subtract, multiply, divide)\r\n== != > <\r\n<= >= <> Comparison (equal, not-equal, less-then, greater-than, etc.)\r\n&  |  ^\t Logical Bitwise (and, or, xor)\r\n&& ||    Logical AND, OR\r\n=\t Assignment expressions\r\n\r\n(FULL JAVA operator Precedence listing)\r\n---------------------------------------\r\n.  []  ()\t\tAccessMethod(dot-operator), Array-Brackets, Parentheses\r\n++  --  !  ~ instanceof\t[not] instanceof returns TRUE or FALSE (object [not] ~instanceof(ClassName))\r\n\t\t\tincrement, decrement\r\nnew (type)expression\tnew instance creation, Parentheses used to Cast values to another type\r\n*  /  %\t\t\tMultiplication, Division, Modulus (remainder)\r\n+  -\t\t\tAddition, Subtraction\r\n<<  >>  >>>\t\tBitwise left or right shift\r\n<>  >=  <=\t\tRelational comparison tests\r\n==  !=\t\t\tEquality comparison tests\r\n&\t\t\tAND/bitwise\r\n^\t\t\tXOR/bitwase\r\n|\t\t\tOR/bitwise\r\n&&\t\t\tAND/logical\r\n||\t\t\tOR/Logical\r\n? :\t\t\tTernary Operator. return = (BooleanExpression ? TrueResp : FalseResp);\r\n%=  +=  .=  -=  /=  ^=\t(shorthand) Assignment Operators )(also plain old = assignemnts)\r\n&= !=  <<=  >>=  >>>=\t(other)  Assignment Operators\r\n\r\nBitwise operator meanings:\r\n>>\tShift right with sign extension\r\n<<\tShift left with zero fill\r\n>>>\tShift right with zero fill\r\n\r\n16 >> 2 yields 4\r\n16      = 0001 0000\r\nshift 2 = 0000 0100, which = 4\r\n\r\n128 >> 2 yields 224\r\n128     = 1000 0000\r\nshift 2 = 1110 0000, which  = 224\r\n>> fills the leftmost bit with its previous value\r\n\r\n128 >>>  2 yields 32\r\n128     = 1000 0000\r\nshift 2 = 0010 0000, which = 32 \r\n>>> fills the leftmost bit with 0\r\n\r\nx = x << 2 is equivalent to x <<= 2\r\n\r\n-------------------------------------------------------\r\nString 'math':\r\n--------------\r\nSystem.out.println(\"Four Score and \" + 7 + \"years ago\"); // OK because println() is overloaded for multiple data types\r\n\r\npublic void sysPrintLn( String[] args ) {\r\n\tint prtArgs = args.length - 1;\r\n\tfor (int i=0; i<args.length; i++) {\r\n\t\tSystem.out.print(args[i]);\r\n\t\tif (i < prtArgs) {System.out.print(' ');}\r\n\t\telse {System.Out.print('\\n');}\r\n\t}\r\n}\r\n\r\nfloat investment = 14000.00;\r\ninvestment *= 1.4;   // increase by 40% year 1\r\ninvestment -= 1500;  // lost $1500      year 2\r\ninvestment *= 1.12;  // increase by 12% year 3\r\nOR\r\ninvestment = (((investment * 1.4) - 1500) * 1.2); // each year's activity in a new set of paretheses\r\n\r\npublic void divide_remain( int main, int divisor) {\r\n\tint quotient  = main / divisor;\r\n\tint remainder = main % divisor;\r\n\tSystem.out.println(main+'/'+divisor+' = '+quotient + '\\tremainder = '+remainder);\r\n}\r\n\r\nclass Customer {\r\n\tclass Order {\r\n\t\tprivate String orderID = '';\r\n\t\tprivate int orderStatus = 0; // 0=no status, 10=pending, 20=paid, 30=shipped, 40=canceled , other values...\r\n\t\tprivate Boolean fileComplaint = false;\r\n\r\n\t\t// class code here\r\n\r\n\r\n\t\tpublic Order cancelOrder(object Order) {\r\n\t\t\t// this method returns an Order object\r\n\t\t\tif (this.orderID = Order.orderNum) {\r\n\t\t\t\tthis.Order.orderStatus = 40;\r\n\t\t\t}\r\n\t\t\treturn this.Order;\r\n\t\t}\r\n\t\tpublic Boolean changeComplaintStatus() {\r\n\t\t\tthis.fileComplaint = !this.fileComplaint;\r\n\t\t}\r\n\t\tpublic void fileComplaint(object Order) {\r\n\t\t\tif (this.fileComplaint == true) {\r\n\t\t\t// code\r\n\t\t\t}\r\n\t\t}\r\n\t} \t// end class Order\r\n}\t\t// end class Customer\r\n\r\nFormatting Strings:\r\n-------------------\r\nint accountBalance = 5001;                             // input an int value\r\nSystem.out.format(\"Balance: $%,%dn\", accountBalance);  // produces '%5,001'\r\ndouble pi = Math.PI;                                   // store Math.PI to variable because Math.PI is static, final\r\nSystem.out.format(\"pi = %.11f%n\",pi);                  // produces '3.14159265359'\r\nfloat gradePtAvg = 3.25F;\t\t// Numeric Literal (F = Floating Point nuber, or float)\r\nSystem.out.println(\"My GPA is \" + gpa);\r\n\r\n\r\nCASTING:\r\n----------------------------\r\nClass Employee {\r\n\t// Base class\r\n\t// code for this class\r\n}\r\nclass VicePresident extends Employee {\r\n\t// inherits from Employee{}\r\n\t// code for this class\r\n}\r\nEmployee      emp  = new Employee();      // emp  is a member of the Employee      class\r\nVicePresident veep = new VicePresident(); // veep is a member of the VicePresident class\r\n// because all VicePresidents are Employees\r\nemp  = veep;               // no type-casting needed for Upward use ('upcasting')\r\n// But because only some Employees are VicePresidents\r\nveep = (VicePresident)emp; // Explicit type-casting needed for this ('downcasting')\r\n\r\n\r\nINSTANCES Value and Equality\r\n-----------------------\r\npublic static void main(String[] args) {\r\n\tString str1, str2;\r\n\tstr1 = \"We the People\";\r\n\t\r\n\tstr2 = str1;\t\t // assignment: str1 and str2 refer to the same object instance\r\n\tSystem.out.println(\"Same Object? \"+(str1 == str2));\t// prints 'true'\r\n\tSystem.out.println(\"Same value?  \"+str1.equals(str2));\t// prints 'true'\r\n\t\r\n\tstr2 = new String(str1); // assignment: create a new String object, set value = str1\r\n\tSystem.out.println(\"Same Object? \"+(str1 == str2));\t// prints 'false'\r\n\tSystem.out.println(\"Same value?  \"+str1.equals(str2));\t// prints 'true'\r\n}\r\n\r\nARRAYS in JAVA:\r\n===============\r\nString players = new String[11]; // create an array with 11 strings, name = 'players'\r\n\r\n\r\n/////////////////////////////////////////////////////////////////\r\n// Object Oriented Programming (simple example):\r\n// This application will display a 'Hello World!' message on a\r\n// user's console by creating n instance of the Greeter class,\r\n// and then calling the Greeter Object's sayHello() method.\r\n////////////////////////////////////////////////////////////////\r\npublic class HelloApp\r\n{\r\n   \r\n   public static void main(String[] args)\r\n   {\r\n       private boolean passArgs;\r\n       private String  argPassList = '';\r\n       \r\n       if (args.length < 1) \r\n       {   // just put the 'Hello World!' message out to the Console\r\n           passArgs = false;\r\n           ConsoleGreeter myGreeterObject = new ConsoleGreeter();\r\n       }\r\n       else if (args.length == 1) \r\n       {\r\n           if (args[0].equalsIgnoreCase(\"response-window\") \r\n           {   // just put the 'Hello World!' message out to a RepsonseWindow\r\n               passArgs    = false;\r\n               RespWinGreeter myGreeterObject = new RespWinGreeter();\r\n           }\r\n           else\r\n           {\r\n               passArgs    = true;\r\n               argPassList = args[0];\r\n               ConsoleGreeter myGreeterObject = new ConsoleGreeter();\r\n           }\r\n       }\r\n       else // if (args.length >= 1)\r\n       {\r\n           passArgs = true;\r\n           \r\n           int start;\r\n           start = (args[0].equalsIgnoreCase(\"response-window\")) ? 1 : 0 ;\r\n           \r\n           argPassList = assemblePhrase(args, start)\r\n           argPassList = argPassList.trim();\r\n           \r\n           if (start == 1) \r\n           {   // args[0] = 'response-window'\r\n               RespWinGreeter myGreeterObject = new RespWinGreeter();\r\n           }\r\n           else \r\n           {\r\n               ConsoleGreeter myGreeterObject = new ConsoleGreeter();\r\n           }   // ... if (start == 1)\r\n       }       // ... if (args.length < 1)\r\n       \r\n       if (passArgs == true) \r\n       {\r\n               myGreeterObject.sayHello(argPassList);\r\n       }\r\n       else // passArgs = false\r\n       {\r\n               myGreeterObject.sayHello();\r\n       }      // ... if (passArgs == true) \r\n   }          // end main()\r\n   \r\n   public string assemblePhrase(String strArray, int startArg)\r\n   {\r\n       String returnStr = '';\r\n       for (int i = startArg; i < strArray.length; i++)\r\n       {\r\n           returnStr = returnStr + ' ' + strArray[i];\r\n       }\r\n       return returnStr;\r\n   }\r\n\r\n// end of class HelloApp\r\n}\r\n\r\npublic class ConsoleGreeter\r\n{\r\n   public void sayHello()\r\n   {\r\n       System.out.println(\"Hello World!\");\r\n   }\r\n   public void sayHello(String[] toWhom)\r\n   {\r\n       String toYou = HelloApp.assemblePhrase(toWhom,0);\r\n       System.out.println(\"Hello\" + toYou + \"!\");\r\n   }\r\n// end of class ConsoleGreeter\r\n}\r\n\r\npublic class RespWinGreeter\r\n{\r\n   public void sayHello()\r\n   {\r\n       JOptionPane.showMessageDialog(null, \"Hello World!\", JOptionPane.INFORMATION_MESAGE);\r\n   }\r\n   public void sayHello(String[] toWhom)\r\n   {\r\n       String toYou = HelloApp.assemblePhrase(toWhom,0);\r\n       JOptionPane.showMessageDialog(null, \"Hello\" + toYou + \"!\", JOptionPane.INFORMATION_MESAGE);\r\n   }\r\n// end of class RespWinGreeter\r\n}\r\n\r\nJAVA INNER CLASS\r\nInner Classes (example):\r\n-------------------------\r\nClass OuterClassName\r\n{\r\n    public static void main(string[] args)\r\n    {\r\n       // main() method code \r\n    }\r\n    \r\n    private class InnerClassName\r\n    {\r\n       // code defining the body of the inner class\r\n       // inner classes can have private, public, or protected visibility\r\n       // inner classes carry a reference to the outerClass\r\n       // inner-classes have access to all fields, methods, and instance-variables of their outer-class\r\n       // because of the outer-class reference, you can create or refer to inner-classes from outer-class static methods -- e.g. main() -- \r\n       // BUT you can create a static inner-class\r\n    }\r\n}\r\n\r\nANONYMOUS CLASS\r\nAnonymous Classes (example):\r\n------------------------------\r\npublic class AnonymousClassBall\r\n{\r\n   public static void main(string[] args) \r\n   {\r\n       Ball b = new Ball()\r\n       {\r\n           public void hitBall()\r\n           {\r\n               System.out.println(\"You hit the Ball!\");\r\n           }\r\n       }; // note - this ends the new Ball() statement\r\n       b.hitBall();\r\n   }\r\n   \r\n   interface Ball // interface for AnonymousClassBall\r\n   {\r\n       void hitBall();\r\n   }\r\n}\r\n\r\nTo delcare and instantiate the AnonymousClassBall class;\r\nnew AnonymousClassball() { class-body } // call the Anonymous class directly\r\nOR\r\nnew Ball() { class-body } // call the interface that implements the Anynymous class\r\n\r\n\r\nLambda Expressions:\r\n---------------------\r\nA lambda expression allows creation of an anonymous class instance that implements a functional interface.\r\nThe hitBall() method, in the AnonymousClassBall{} class, meets that definition.\r\nA functional interface must contain one abstract method, and may contain other concrete methods.\r\n\r\nLambda functions are a quick way to create anonymous classes that implement functional interfaces. Instead of defining a formal method declaration which includes a return-type, method-name, parameter-types, and method-body-code, you just define teh parameter types and method-body-commands. The Java compiler infers the rest, based on the context of the Lambda expression.\r\nExample:\r\n() -> { System.out.println(\"You hit the ball!\");} // this Lambda-Expression implements the interface whose abstract method takes no parameters.\r\n\"->\" = 'Arrow Operator'\r\n\r\nFor the anonymous class above, the coding would look like  this:\r\n\r\npublic class LambdaBall\r\n{\r\n   public static void main(string[] args) \r\n   {\r\n       Ball b = () -> {System.out.println(\"You hit the Ball!\");}; // notice 2 semicolons: 1=end of embedded lambda-command,2=end of main() command\r\n       b.hitBall();\r\n   }\r\n   \r\n   interface Ball // interface for LambdaBall\r\n   {\r\n       void hitBall();\r\n   }\r\n}\r\n\r\n\r\nSTATIC FIELDS & METHODS:\r\n------------------------\r\nStatic fields and methods are asociated with an entire Class, not a specific Object which is an instance of the Class. \r\nIt's not necessary to crate an 'instance of the class' (object) in order to access a Static Variable or Static Method.\r\n\r\nUses/reasons for Static fields and methods:\r\n1. To provide constants or other values that aren't tied to a spacific class instance (example: a tax rate applicable to all taxable items)\r\n2. To keep a count of how many instances of a class have been created or are active\r\n3. To maintain a reference value (e.g. invoice numbers, or serial numbers which are incremented or generated according a set of rules).\r\n4. To provide alternative ways to crete class instances. Example: Java NumberFormat class has getCurrencyInstance() and getNumberInstance that return Object instances to format numeric values in specific ways.\r\n   Note: the NumberFormat example also describes a 'Singleton Class' and Singleton Pattern.\r\n5. To provide a set of utility functions to a Class that aren't associated with a specific object. Examples include many types of data validation.\r\n\r\nStatic variables or fields can be declared  private outside of any class methods. BUT...\r\n... Because static variables and methods are available to an entire class (all instances or objects of the Class Type), static variables can't be declared in private methods.\r\n\r\nSINGLETON PATTERN\r\n-----------------\r\nA singleton is a class where only ONE instance is created.  \r\nCreating a private constructor will prevent the class from being instantiated externally.\r\nCreating a public method that controls instantiation allows one and only one instance of the class to be created.\r\n\r\npublic class SingletonClass \r\n{\r\n   private static SingletonClass instance;   // delcare a Field for an instance reference\r\n   // this variable maintains a reference to an object (instance of the Class)\r\n\r\n   private SingletonClass() {}               // default constructor for instance reference\r\n   // declaring this private will pevent the constructor from being used or called from\r\n   // outside the Class, and thus prevent new instances from being instantiated if one already exists\r\n   \r\n   public static SingletonClass getInstance()\r\n   {                                         // static function -- same method used by all class instances\r\n       if (instance == null) {               // if there is no instance\r\n            instance = new SingletonClass(); // then create one [set the private static Field, above]\r\n       }\r\n       return instance;                      // return a reference to the instance\r\n   }\r\n}\r\n\r\n//////////////////////////////////////////\r\n// commands to run the Singleton Class: //\r\n//////////////////////////////////////////\r\nSingletonClass obj1 = SingletonClass.getInstance();\r\nSingletonClass obj2 = SingletonClass.getInstance();\r\nif (obj1 == obj2) {\r\n    System.out.println(\"The objects are the same.\");\r\n}\r\nelse {\r\n    System.out.println(\"The objects are not the same.\");\r\n}\r\n\r\nActual code snippet from the Java Math Class:\r\n=============================================\r\npublic final class Math {\r\n   \r\n   /** \r\n    * Don't allow anyone to instantiate this class\r\n    */\r\n   private Math() {}\r\n   ...\r\n   ... much more code\r\n   ...\r\n}\r\n\r\nEMBEDDED JAVA:\r\nhttp://www.onjava.com/pub/st/54\r\n\r\nTutorial:\r\nhttp://www.oracle.com/technetwork/java/index.html\r\nhttp://www.onjava.com/pub/a/onjava/synd/2001/08/15/embedded.html\r\nSECURITY:\r\nhttp://www.pcworld.com/article/2030778/researchers-javas-security-problems-unlikely-to-be-resolved-soon.html\r\n\r\nJVM\r\n====\r\nJVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.  \r\nJVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent. \r\nThe JVM performs following main tasks: •Loads code\r\n•Verifies code\r\n•Executes code\r\n•Provides runtime environment\r\n \r\nJRE\r\n====\r\nJRE is an acronym for Java Runtime Environment.It is used to provide runtime environment.It is the implementation of JVM.It physically exists.It contains set of libraries + other files that JVM uses at runtime.  \r\nImplementation of JVMs are also actively released by other companies besides Sun Micro Systems.  \r\n\r\nJDK\r\n====\r\nJDK is an acronym for Java Development Kit.It physically exists.It contains JRE + development tools.  \r\n\r\n=====================\r\n(some) Java Packages:\r\n---------------------\r\njava.applet\t\tAllows  you to build applets\r\njava.awt\t\tAbstract Window Toolkie - so that Graphical User Interfaces can be constructed in Java\r\njava.awt.event\t\tHandles events raised by AWT components\r\njava.beans\t\tServes as the basis for software components\r\njava.io\t\t\tSupports File input + output\r\njava.lang\t\tprovides core java functionality\r\njava.net\t\tEnables neworking \r\njava.util\t\tProvides several utiltity functions used in java\r\njava.math\t\tSupports mathematic & arithmetic operations\r\n\r\nVariables.\r\nJAVA PRIMITIVES:\r\n----------------\r\nvariables and function return-types can be any Java Primitive type\r\n- int\t\t32 bits\t\tsigned integers -2,147,483,648 to +2,147,438,647 (-2^31 to +2^31 - 1)\r\n- long\t\t64 bits\t\tsigned integers -2^63 to +2^63 - 1\r\n- char\t\t16 bits\t\tunicode char set\r\n- short\t\t16 bits\t\tsigned integers -32,768 to +31767 (-2^15 to +2^15 - 1)\r\n- byte\t\t 8 bits \tsigned integers -128 to +127      (-2^7  to  +2^7 - 1)\r\n- float\t\t32 bytes\tsigned floating point numbers\r\n- double\t64 bits\t\tsigned floating point numbers\r\n- boolean\ttrue or false values\r\n- void (used in methods to indicate no return-type)\r\n\r\nJAVA WRAPPER CLASSES:\r\n---------------------\r\nBoolean class\r\n=====================\r\n--- static methods ---\r\nboolean getBoolean(String s)\t\t\treturns the boolean value corresonding to s\r\nBoolean valueOf(String s)\t\t\treturns a Boolean object encapsulating the String value = s\r\n\r\n--- instance methods ---\r\nboolean thisObj.BooleanValue()\t\t\treturns the boolean value encapsulated by the current object\r\n\r\nBoolean constructors:\r\n------------------\r\nBoolean(boolean b)\r\nBoolean(String s)\r\n\r\n\r\nInteger class\r\n=====================\r\n--- static methods ---\r\nstatic Integer decode(String s) throws NumberFormatException\t\treturns Integer object containing value = s[base-10]\r\nstatic Integer valueOf(String s) throws NumberFormatException\t\treturns Integer object containing value = s[base-10]\r\nstatic Integer valueOf(String s, int B) throws NumberFormatException\treturns Integer object containing value = s[base-B]\r\nstatic int parseInt(String s) throws NumberFormatException\t\treturns int primitive s[base-10]\r\nstatic int parseInt(String s, int B) throws NumberFormatException\treturns int primitive s[base-B]\r\nstatic String toBinaryString(int i)\t\t\t\t\treturns String object containing value = i in Binary [base-2]\r\nstatic String toOctalString(int i)\t\t\t\t\treturns String object containing value = i in Octal [base-8]\r\nstatic String toHexString(int i)\t\t\t\t\treturns String object containing value = i in Hex [base-16]\r\n\r\n--- instance methods ---\r\nbyte  thisObj.byteValue()\t\t\treturns the byte equivalent of the current object\r\nshort thisObj.shortValue()\t\t\treturns the short equivalent of the current object\r\nint   thisObj.intValue()\t\t\treturns the int equivalent of the current object\r\nlong  thisObj.longValue()\t\t\treturns the long equivalent of the current object\r\ndouble thisObj.doubleValue()\t\t\treturns the double equivalent of the current object\r\nfloat  thisObj.floatValue()\t\t\treturns the float equivalent of the current object\r\nString thisObj.toString()\t\t\treturns the String equivalent of the current object\r\nboolean thisObj.equals(Object obj)\t\treturns TRUE if the object values are the same\r\n\r\nChar class\r\n=====================\r\n--- static methods ---\r\nboolean isDigit(char c)\t\t\t\treturns TRUE if c is a digit\r\nboolean isLetter(char c)\t\t\treturns TRUE if c is a letter\r\nboolean isLetterOrDigit(char c)\t\t\treturns TRUE if c is a letter or digit\r\nboolean isLowerCase(char c)\t\t\treturns TRUE if c is a lowercase letter\r\nboolean isUpperCase(char c)\t\t\treturns TRUE if c is an uppercase letter\r\nboolean isWhitespace(char c)\t\t\treturns TRUE if c is a whitespace-character NOT(letter, digit, puctuation, other-non-blank)\r\nboolean isSpaceChar(char c)\t\t\treturns TRUE if c is a plain space\r\nchar toUpperCase(char c)\t\t\treturns the UpperCase equivalent of c\r\nchar toLowerCase(char c)\t\t\treturns the lowercase equivalent of c\r\n\r\n--- instance methods ---\r\nByte thisObj.decode(String s) throws NumberFormatException\t\treturns Byte object containing value = s[base-10]\r\nByte thisObj.valueOf(String s) throws NumberFormatException\t\treturns Byte object containing value = s[base-10]\r\nByte thisObj.valueOf(String s, int B) throws NumberFormatException\treturns Byte object containing value = s[base-B]\r\nbyte thisObj.parseByte(String s) throws NumberFormatException\t\treturns byte primitive s[base-10]\r\nbyte thisObj.parseByte(String s, int B) throws NumberFormatException\treturns byte primitive s[base-B]\r\nString thisObj.toString()\t\t\t\t\t\treturns the String equivalent of the current object\r\nbyte  thisObj.byteValue()\t\t\t\t\t\treturns the byte equivalent of the current object\r\nshort thisObj.shortValue()\t\t\t\t\t\treturns the short equivalent of the current object\r\nint   thisObj.intValue()\t\t\t\t\t\treturns the int equivalent of the current object\r\nlong  thisObj.longValue()\t\t\t\t\t\treturns the long equivalent of the current object\r\ndouble thisObj.doubleValue()\t\t\t\t\t\treturns the double equivalent of the current object\r\nfloat  thisObj.floatValue()\t\t\t\t\t\treturns the float equivalent of the current object\r\nString thisObj.toString()\t\t\t\t\t\treturns the String equivalent of the current object\r\n\r\nSimilar methods exist for the Short, Long, Double and Float  classes.\r\n\r\nShort constructors:\r\n------------------\r\nShort(short sh)\r\nShort(String s) throws NumberFormatException\r\n\r\nByte constructors:\r\n------------------\r\nByte(byte b)\r\nByte(String s) throws NumberFormatException\r\n\r\n\r\n\r\nLong class\r\n=====================\r\nThis class includes two numeric constants (static final variables) MAX_VALUE, MIN_VALUE (the maximum and minimum values that the class can accommpodate)\r\nMIN_VALUE = -2^31, MAX_VALUE = +2^31 - 1\r\nLong classe also static define conditions (static final variables) POSITIVE_INFINITY (> MAX_VALUE), NEGATIVE_INFINITY (< MIN_VALUE), and NaN (Not a Number, Boolean)\r\nThe static methods are similar to those for the Integer and Short classes, except that they resolve to either a Long object, or a long primitive \r\ne.g.: long parseLong(String s) throws NumberFormatException\r\n      Long valueOf(String s) throws NumberFormatException\r\n\r\nboolean thisObj.isInfinite()\t\t\t\treturns TRUE if the value is NEGATIVE_INFINITY or POSITIVE_INFINITY\r\nboolean thisObj.isNaN(long l)\t\t\t\treturns TRUE if the value is not a number (e.g. devision by zero)\r\n\r\nLong constructors:\r\n------------------\r\nLong(long l)\r\nLong(String s) throws NumberFormatException\r\n\r\nFloat class, \r\nDouble class\r\n=====================\r\nsimilar to the Long class\r\nDouble class has its own static final values for MAX_VALUE and MIN_VALUE \r\nDouble and Float classes also define static conditions (static final variables) POSITIVE_INFINITY (> MAX_VALUE), NEGATIVE_INFINITY (< MIN_VALUE), and NaN (Not a Number, Boolean)\r\n\r\nFloat uses floating point (decimal) values, not integers, so the MIN_VALUE and MAX_VALUE constants are differetn:\r\nSystem.out.println(Double.MAX_VALUE);\t// prints 1.7976931348623157E308\r\nSystem.out.println(Double.MIN_VALUE);\t// prints 4.9E-324\r\n\r\nDouble constructors:\r\n--------------------\r\nDouble(double d)\r\nDouble(String s) throws NumberFormatException\r\n\r\nFloat constructors:\r\n-------------------\r\nFloat(float f)\r\nFloat(double d)\r\nFloat(String s) throws NumberFormatException\r\n\r\n\r\nStrings and the StringBuffer class\r\n==================================\r\nconstructors:\r\n  StringBuffer()\r\n  StringBuffer(int size)\r\n  StringBuffer(String s)\r\n\r\nStringBuffer Instance Methods:\r\nStringBuffer append(boolean b)\t\tAppends the string equivalent of b\r\nStringBuffer append(char ch)\t\tAppends ch\r\nStringBuffer append(double d)\t\tAppends the string equivalent of d\r\nStringBuffer append(float f)\t\tAppends the string equivalent of f\r\nStringBuffer append(long l)\t\tAppends the string equivalent of l\r\nStringBuffer append(int i)\t\tAppends the string equivalent of i\r\nStringBuffer append(Object obj)\t\tAppends the string equivalent of obj\r\nStringBuffer append(String s)\t\tAppends value of s (or the string equivalent of  s)\r\nStringBuffer insert(int i, boolean b)\tInserts the string equivalent of b before index i\r\nStringBuffer insert(int i, char ch)\tInserts ch before index i\r\nStringBuffer insert(int i, int j) \tInserts the string equivalent of j before index i\r\nStringBuffer insert(int i, long l)\tInserts the string equivalent of l before index i\r\nStringBuffer insert(int i, Object obj)\tInserts the string equivalent of obj before index i\r\nStringBuffer insert(int i, String s)\tInserts the string equivalent of s before index i\r\nStringBuffer reverse()\t\t\tReverses the order of the Stringbuffer contents\r\nint capacity()\t\t\t\tReturns the current capacity of the String Buffer\r\nint length()\t\t\t\tReturns the number of characters in the String Buffer\r\nvoid setLength(int i)\t\t\tSets the buffer capacity to i\r\nvoid setCharAt(int i, char ch)\t\tSets the character at index i = ch\r\nchar charAt(int i)\t\t\tReturns the character at index i\r\nString toString()\t\t\tReturns a String object containing the character sequence\r\n\r\n\r\n\r\n\r\nINTERFACES:\r\n===========\r\nAn interface is a set of constants and method declarationss that define the form of a Class (What the class can do), but with no implementations (nothing stating How the class accomplishes its  functions)\r\n\r\nVariables declared in an Interface are (implicitly) static, public, and final; meaning, they are constants.\r\nFunctions prototyped in an Interface are (implcitly) Public and Abstract; they have no implementation\r\n\r\nThe default Modifier for an interface provides access to code in the same Package [package-level]\r\nA 'Public' Modifier for an interface allows for access outside the Package (access from other Packages)\r\n\r\nA class can implement many interfaces -- but can only extend (inherit-from) one other class.\r\n\r\nInterfaces can extend other interfaces.\r\n\r\n/* \r\n * instanceof operator - \r\n * can be used to test whether or not an object implements a particular Interface \r\n * can be used to test whether or not an object is an instance of a particular Class\r\n */\r\ninterface Vehicle { void Drive(); }\r\n\r\nabstract class Mammal {}\r\nclass Bear extends Mammal {}\t// doesn't implement Vehicle\r\nclass Impala extends Mammal implements Vehicle {\r\n   // implements Vehicle, so Vehicle methods must be implemented\r\n   public void Drive() { System.out.println(\"Impala: Drive()\";}\r\n}\r\nclass Mustang extends Mammal implements Vehicle {\r\n   // implements Vehicle, so Vehicle methods must be implemented\r\n   public void Drive() { System.out.println(\"Mustang: Drive()\";}\r\n}\r\nclass Lion extends Mammal {}\t// doesn't implement Vehicle\r\n\r\nclass InstanceOfInterface {\r\n   public static final NUM_OF_MAMMALS = 4;\r\n   \r\n   public static void main(String[] args) {\r\n\t// create an Array of Mammals:\r\n\tMammal mammals = new Mammal[NUM_OF_MAMMALS];\r\n\t// create objects:\r\n\tmammals[0] = new Bear();\r\n\tmammals[1] = new Impala();\r\n\tmammals[2] = new Mustang();\r\n\tmammals[3] = new Lion();\r\n\t// use instanceof operator:\r\n\tfor (int i=0; i<NUM_OF_MAMMMALS; i++) {\r\n\t    if (mammals[i] instanceof Vehicles) {\r\n\t\tVehicle v = (Vehicle)mammals[i];\r\n\t\tv.Drive();\r\n\t    }\r\n\t}\r\n    }\r\n}\r\noutput:\r\nImpala: drive()\r\nMustang: Drive()\r\n----------------------------------------\r\n\r\nif (objectName instanceof ClassName) { \r\n   // [objectName is an instance of ClassName]\r\n   // commands \r\n}\r\n\r\nAbstract Classes v. Interfaces:\r\n-------------------------------\r\nThey are Similar, but an Abstract Class is inherited, an Interface is implemented.\r\nJava interface are invoked using the keyword ''implements''; A Java abstract class is extended (inherited) using keyword ''extends''.\r\n\r\nA Class is abstract if any of its methods is declared as Abstract\r\nA class extending an Abstract Class must implement ALL of the abstract methods of the parent class, or must be itself an Abstract class.\r\nAn abstract class can have 'concrete' methods (instance methods that implement 'default' behavior)\r\nInterface methods are all public and abstract. No Interface methods can be implemented in the Interface.\r\nInterface variables are all public, static, and final.\r\nVariables declared in a Java interface are final (by default). An abstract class may contain non-final variables.\r\nMembers of a Java interface are public by default. A Java abstract class can have the usual flavors of class members .. private, protected, etc..\r\nLike a Java Class, a Java interface can extend another Java interface, \r\nA Java class can implement multiple interfaces but it can extend only one abstract class\r\nAn Abstract class has constructors, even if they are not declared or implemented in the Abstract Class. Inerfaces have no constructors.\r\n\r\n\r\nQ: Where would you choose  to use an Interface or  Abstract class?\r\nA: Example:\r\n\r\npublic interface LoginAuth{\r\n   public String encryptPassword(String pass);\r\n   public void checkDBforUser();\r\n}\r\n\r\n/*\r\n * Now suppose you have 3 databases used by your enterprise applications. \r\n * Then each and every implementation for those database needs to define the 2 methods in the interface: \r\n */\r\npublic class DBMySQL implements LoginAuth{\r\n          // Needs to implement both methods\r\n\tpublic String encryptPassword(String pass) {\r\n\t\t// encode & encrypt method\r\n\t}\r\n\tpublic void checkDBforUser() {\r\n\t\t// build  SQL or call Stored procedure\r\n\t}\r\n}\r\npublic class DBOracle implements LoginAuth{\r\n          // Needs to implement both methods\r\n\tpublic String encryptPassword(String pass) {\r\n\t\t// encode & encrypt method\r\n\t}\r\n\tpublic void checkDBforUser() {\r\n\t\t// build  SQL or call Stored procedure\r\n\t}\r\n}\r\npublic class DBAbc implements LoginAuth{\r\n          // Needs to implement both methods\r\n\tpublic String encryptPassword(String pass) {\r\n\t\t// encode & encrypt method\r\n\t}\r\n\tpublic void checkDBforUser() {\r\n\t\t// build  SQL or call Stored procedure\r\n\t}\r\n}\r\n\r\n// if encryptPassword() is not database dependent, and it's the same for each class, then\r\n// a single method implemented in an abstract 'parent' class will br sufficient.\r\n//\r\npublic abstract class LoginAuth{\r\n   public String encryptPassword(String pass){\r\n            // Implement the same default behavior here \r\n            // that is shared by all subclasses.\r\n   }\r\n   // Each subclass needs to provide their own implementation of this abstract method:\r\n   public abstract void checkDBforUser();\r\n}\r\npublic class DBMySQL extends LoginAuth{\r\n\tpublic void checkDBforUser(String userID) {\r\n\t\t// build  SQL or call Stored procedure\r\n\t}\r\n}\r\npublic class DBOracle extends LoginAuth{\r\n\tpublic void checkDBforUser(String userID) {\r\n\t\t// build  SQL or call Stored procedure\r\n\t}\r\n}\r\npublic class DBAbc extends LoginAuth{\r\n\tpublic void checkDBforUser(String userID) {\r\n\t\t// build  SQL or call Stored procedure\r\n\t}\r\n}\r\n\r\nAnother example:\r\n------------------------------\r\npublic interface Payment [\r\n    void recordPayment();      //by default it is a abstract method\r\n}\r\n\r\n\r\npublic class PayPal implements Payment {\r\n    public void recordPayment() {\r\n        //some logic for paypal payment\r\n        //e.g. get, use Paypal username and password for payment\r\n    }\r\n}\r\n\r\npublic class CreditCard implements Payment {\r\n    public void recordPayment() {\r\n        //some logic for CreditCard payment\r\n        //e.g.get CreditCard number, date of expiry etc...\r\n    }\r\n}\r\npublic class MoneyOrder implements Payment {\r\n    public void recordPayment() {\r\n        //some logic for Money Order payment\r\n        //e.g. put order on HOLD until Money Order  clears\r\n    }\r\n}\r\n\r\n// regardless of  how a paymment is  recorded, \r\n// the product or  service delivery might be best handled by implementations of an Abstract Class\r\npublic abstract class ManageInventory {\r\n    public void generate order();\r\n    public void updateInventory();\r\n    public void itemsToBuyer();\r\n}\r\npublic class ProductDelivery extends ManageInventory {\r\n    public void generate order() { /* generate paperwork for  the order */ }\r\n    public void updateInventory() { /* take items from inventory for shipment */}\r\n    public void itemsToBuyer() { /* ship  goods */ }\r\n}\r\npublic class ServiceDelivery extends ManageInventory {\r\n    public void generate order() { /* generate paperwork for  the order */ }\r\n    public void updateInventory() { /* assign staff, etc. */}\r\n    public void itemsToBuyer() { /*  provide the services */ }\r\n}\r\n\r\n\r\n-----------------------------------------------\r\nCLASS MODIFIERS:\tpublic, abstract, final\r\nVARIABLE MODIFIERS:\tpublic, protected, private, static, final, volatile, transient\r\nCONSTRUCTOR MODIFIERS:\tpublic, protected, private\r\nMETHOD MODIFIERS:\tpublic, protected, private, static, final, abstract, native, synchronized\r\n\r\n\r\nCLASSPATH variable:\r\n===================\r\nthe ClassPath is how the Java compiler 'finds' classes to compile and builds packages.\r\nA CLASSPATH specifies the 'root' for classes you want to manage and use for application packages\r\n\r\nexample:\r\nCLASSPATH = C:\\JavaClasses\\\r\npackage  path \t\t\t\timport statement in *.java files\r\n-------------\t\t\t\t--------------------------------\r\nC:\\JavaClasses\\nonVisual\\utils\\\t\timport nonVisual.utils.*; // for ALL items in ..\\utils\\\r\nC:\\JavaClasses\\dataBase\\Access\\\t\timport dataBase.Access.*; // for ALL items in ..\\Access\\\r\n\r\nJava ARchive (JAR) Files:\r\n=========================\r\njar [options] jar_File [manifest_File] class-file1, class_file2, ...\r\njar command-line options:\r\n  c\tCreate a new jar file\r\n  u\tupdate an existing jar file\r\n  x\tExtracts files from an existing jar file\r\n  t\tList the contents of a jar file\r\n  f\tIndicates that the jar-file is specified as an option (almost always use this option)\r\n  v\tVerbose  output - display details of each action\r\n  0\tNo file-compression when adding to an archive (0% compression)\r\n  m\tSpecifies that a manifest_file is provided (next argument, fllowing the jar_file name)\r\n  M\tSpecifies that a manifest_file should not be added to the archive (rarely used).\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}